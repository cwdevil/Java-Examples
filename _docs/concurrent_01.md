Thread.sleep() 用于暂停当前线程的活动。

线程可以有如下 6 种状态: 
•New (新创建) 
•Runnable (可运行) 
•Blocked (被阻塞) 
•Waiting (等待)
•Timed waiting (计时等待) 
•Terminated (被终止)

* New
当用 new 操作符创建一个新线程时, 如 newThread(r), 该线程还没有开始运行。这意味 着它的状态是 new。 
* Runnable
一旦调用 start 方法, 线程处于 runnable 状态。
一个可运行的线桿可能正在运行也可能没 有运行, 这取决于操作系统给线程提供运行的时间。
在任何给定时刻, 一个可运行的线程可能正在运行也可能没有运行
* Blocked，Waiting
当线程处于被阻塞或等待状态时, 它暂时不活动。 它不运行任何代码且消耗最少的资 源。 直到线程调度器重新激活它。 细节取决于它是怎样达到非活动状态的。
* 被终止的线程
线程因如下两个原因之一而被终止: 
•因为 run 方法正常退出而自然死亡。
•因为一个没有捕获的异常终止了 run 方法而意外死亡。


线程的各种属性, 其中包括: 线程优先级、守护线程、线程组以及处理未捕 获异常的处理器。
* 线程优先级
每一个线程有一个优先级。 默认情况下, 一+线程继承它的父 线程的优先级。 可以用 setPriority 方法提高或降低任何一个线程的优先级。 可以将优先级设 置为在 MIN_PRIORITY ( 在 Thread 类中定义为 1 ) 与 MAX_PRIORITY ( 定义为 10 ) 之间的 任何值。NORM_PRIORITY 被定义为 5。
在 Oracle 为 Linux 提供的 Java 虚拟机中, 线程的优先级被忽略一所有线程具有相同的优先级。
* 守护线程
可以通过调用 t .setDaemon(true) ;将线程转换为守护线程(daemon thread。) 
守护线程的唯一用途 是为其他线程提供服务。
守护线程应该永远不去访问固有资源, 如文件、 数据库, 因为它会在任何时 候甚至在一个操作的中间发生中断。
* 未捕获异常处理器
不需要任何 catch 子句来处理可以被传播的异常。 相反, 就在线程死亡之前, 异 常被传递到一个用于未捕获异常的处理器。
该处理器必须属于一个实现 Thread.UncaughtExceptionHandler 接口的类。 这个接口只有 —个方法。
void uncaughtException(Thread t, Throwable e)

